<script type="text/html" data-template-name="jack-value">
    <div class="form-row">
        <label for="node-input-name">
            <i class="fa fa-tag"></i> <span data-i18n="@ptweety/node-red-contrib-ccu-jack/messages:common.label.name"></span>
        </label>
        <input type="text" id="node-input-name" data-i18n="[placeholder]@ptweety/node-red-contrib-ccu-jack/messages:value.input.name" style="width: calc(100% - 105px)">
    </div>

    <div class="form-row">
        <label for="node-input-jack">
            <i class="fa fa-globe"></i> <span data-i18n="@ptweety/node-red-contrib-ccu-jack/messages:config.label.name"></span>
        </label>
        <input type="text" id="node-input-jack" style="width: calc(100% - 105px)">
    </div>

    <div class="form-row">
        <label for="node-input-topic">
            <i class="fa fa-tasks"></i> <span data-i18n="@ptweety/node-red-contrib-ccu-jack/messages:common.label.topic"></span>
        </label>
        <input type="text" id="node-input-topic" data-i18n="[placeholder]@ptweety/node-red-contrib-ccu-jack/messages:value.input.topic" style="width: calc(100% - 105px)">
    </div>

    <div class="form-row">
        <label for="node-input-domain"><i class="fa fa-empire"></i> domain</label>
        <select id="node-input-domain"></select>
    </div>

    <div class="form-row">
        <label for="node-input-device">device</label>
        <input type="text" id="node-input-device" class="node-typed-input-property-value" style="width: calc(100% - 105px)">
        <input type="hidden" id="node-input-deviceT" class="node-typed-input-property-type">
    </div>

    <div class="form-row">
        <label for="node-input-channelIndex">channelIndex</label>
        <input type="text" id="node-input-channelIndex" class="node-typed-input-property-value" style="width: calc(100% - 105px)">
        <input type="hidden" id="node-input-channelIndexT" class="node-typed-input-property-type">
    </div>

    <div class="form-row">
        <label for="node-input-datapoint">datapoint</label>
        <input type="text" id="node-input-datapoint" class="node-typed-input-property-value" style="width: calc(100% - 105px)">
        <input type="hidden" id="node-input-datapointT" class="node-typed-input-property-type">
    </div>

    <div class="form-row">
        <label for="node-input-change"> </label>
        <input type="checkbox" id="node-input-change" style="width: 22px; vertical-align: top;">
        <span data-i18n="@ptweety/node-red-contrib-ccu-jack/messages:value.label.change"></span>
    </div>

    <div class="form-row">
        <label for="node-input-cache"> </label>
        <input type="checkbox" id="node-input-cache" style="width: 22px; vertical-align: top;">
        <span data-i18n="@ptweety/node-red-contrib-ccu-jack/messages:value.label.cache"></span>
    </div>

    <div class="form-tips" style="max-width: unset; width: calc(100% - 18px)">
        <b>Important:</b> deploy server node to get devices list
    </div>
</script>

<script type="text/javascript">
(function () {
    'use strict';

    RED.nodes.registerType('jack-value', {
        category: 'Jack',
        color: '#c2abc2',
        defaults: {
            name: { value: '' },
            jack: { value: 'localhost', type: 'jack-config', required: true },
            domain: { value: '*' },
            topic: { value: '*' },
            device: { value: '' },
            deviceT: { value: 'str' },
            channelIndex: { value: '' },
            channelIndexT: { value: 'str' },
            datapoint: { value: '' },
            datapointT: { value: 'str' },
            change: { value: false },
            cache: { value: false },
        },
        align: 'right',
        icon: 'bridge.svg',
        inputs: 1,
        outputs: 1,
        label: function () {
            return this.name || this._('@ptweety/node-red-contrib-ccu-jack/messages:value.label.name');
        },
        paletteLabel: function () {
            return this._('@ptweety/node-red-contrib-ccu-jack/messages:value.label.name');
        },
        outputLabels: function (_) {
            return this._('@ptweety/node-red-contrib-ccu-jack/messages:value.node.output');
        },
        oneditprepare: async function () {
            const $nodeInputJack = $('#node-input-jack');
            const $nodeInputDomain = $('#node-input-domain');
            const $nodeInputTopic = $('#node-input-topic');

            let debug;
            await $.getJSON(`jack?config=${$nodeInputJack.val()}`)
                .done((responseJSON) => {
                    debug = responseJSON?.debug || false;
                    // console.debug('debug', responseJSON);
                })
                .fail((jqXHR, textStatus, error) => {
                    console.debug({ jqXHR, textStatus, error });
                });
            console.debug = debug ? console.debug : function () {};

            const getDomainOptions = async () => {
                console.debug('getDomainOptions()');
                const nodeId = $nodeInputJack.val();

                if (nodeId === '_ADD_') return;

                $nodeInputDomain.empty().append('<option value="">*</option>');
                await $.getJSON(`jack?config=${nodeId}&type=domain`)
                    .done((responseJSON) => {
                        console.debug('domain data', responseJSON);
                        for (const index of Object.keys(responseJSON)) {
                            if (['device', 'virtdev'].includes(index))
                                $nodeInputDomain.append(
                                    '<option value="' +
                                        index +
                                        (index === this.domain ? '" selected>' : '">') +
                                        responseJSON[index].title +
                                        '</option>'
                                );
                        }
                        console.debug(`selected domain: ${$nodeInputDomain.val()}`);
                    })
                    .fail((jqXHR, textStatus, error) => {
                        console.dir({ jqXHR, textStatus, error });
                        RED.notify(`Request failed with: ${jqXHR.status} (${error})`, 'error');
                    });
            };

            let deviceTree = { room: [], function: [], device: [] };
            const getDeviceTree = async () => {
                console.debug('getDeviceTree()');
                const nodeId = $nodeInputJack.val();

                if (nodeId === '_ADD_') return;

                const queryItems = {};
                for (const item of ['device', 'channelIndex', 'datapoint']) {
                    queryItems[item] = $(`#node-input-${item}`).val();
                    queryItems[item + 'T'] = $(`#node-input-${item}T`).val();
                }

                await $.getJSON(`jack?config=${nodeId}&type=tree&domain=${$('#node-input-domain').val()}`, queryItems)
                    .done((responseJSON) => {
                        console.debug('device tree data', responseJSON);
                        deviceTree = responseJSON;
                    })
                    .fail((jqXHR, textStatus, error) => {
                        console.dir({ jqXHR, textStatus, error });
                        RED.notify(`Request failed with: ${jqXHR.status} (${error})`, 'error');
                    });
            };

            $nodeInputJack.on('change', async (event, type, value) => {
                console.debug(`${$(this).attr('id')}.on('change', ${event.target.id}, ${type}, ${value})`);
                await getDomainOptions();
            });

            $nodeInputDomain.on('change', async (event, type, value) => {
                console.debug(`${$(this).attr('id')}.on('change', ${event.target.id}, ${type}, ${value})`);
                await getDeviceTree();
                $nodeInputTopic.trigger('focus');
            });

            $nodeInputTopic.autoComplete({
                delay: 0,
                minLength: 0,
                search: function () {
                    return ['*', '${domain}/status/${device}/${channelIndex}/${datapoint}'].map((value) => {
                        return { value, label: value };
                    });
                },
            });

            // eslint-disable-next-line unicorn/consistent-function-scoping
            const getMatch = (value, searchValue) => {
                const index = value.toLowerCase().indexOf(searchValue.toLowerCase());
                const length = index > -1 ? searchValue.length : 0;
                return {
                    index: index,
                    found: index > -1,
                    pre: value.slice(0, Math.max(0, index)),
                    match: value.slice(index, index + length),
                    post: value.slice(Math.max(0, index + length)),
                };
            };

            const generateSpans = (match) => {
                const elements = [];
                if (match.pre) {
                    elements.push($('<span/>').text(match.pre));
                }
                if (match.match) {
                    elements.push(
                        $('<span/>', {
                            style: 'font-weight: bold; color: var(--red-ui-text-color-link);',
                        }).text(match.match)
                    );
                }
                if (match.post) {
                    elements.push($('<span/>').text(match.post));
                }
                return elements;
            };

            const autoCompleteSearch = (options, value) => {
                console.debug('autoCompleteSearch()');
                let matches = [];
                for (const opt of options) {
                    const optValue = opt.value;
                    const optSource = (opt.source || []).join(',');
                    const valueMatch = getMatch(optValue, value);
                    const sourceMatch = getMatch(optSource, value);
                    if (valueMatch.found || sourceMatch.found) {
                        const element = $('<div>', { style: 'display: flex' });
                        const valueElement = $('<div/>', {
                            style: 'font-family: var(--red-ui-monospace-font); white-space:nowrap; overflow: hidden; flex-grow:1',
                        });
                        valueElement.append(generateSpans(valueMatch));
                        valueElement.appendTo(element);
                        if (optSource) {
                            const optElement = $('<div>').css({ 'font-size': '0.8em' });
                            optElement.append(generateSpans(sourceMatch));
                            optElement.appendTo(element);
                        }
                        matches.push({
                            value: optValue,
                            label: element,
                            i: valueMatch.found ? valueMatch.index : sourceMatch.index,
                        });
                    }
                }

                matches.sort(function (A, B) {
                    return A.i - B.i;
                });
                matches.unshift({ value: '', label: '*' });

                console.debug('matches', matches);
                return matches;
            };

            $('.node-typed-input-property-value').each(function () {
                // const nodeId = $nodeInputJack.val();
                const id = $(this).attr('id');

                switch (id) {
                    default: {
                        const type = id.slice(11);
                        $(this).typedInput({
                            types: [
                                {
                                    value: 'str',
                                    label: 'string',
                                    icon: 'red/images/typedInput/az.svg',
                                    autoComplete: (value) => autoCompleteSearch(deviceTree[type], value),
                                },
                                // { value: 're', label: 'regular expression', icon: 'red/images/typedInput/re.svg' },
                            ],
                            typeField: '#' + $(this).attr('id') + 'T',
                        });

                        $(this).on('change', async (event, type, value) => {
                            console.debug(`${$(this).attr('id')}.on('change', ${event.target.id}, ${type}, ${value})`);
                            await getDeviceTree();
                        });
                    }
                }
            });
        },
        oneditsave: function () {
            // const $nodeInputDomain = $('#node-input-domain');
            // const domain = $nodeInputDomain.val() || '';
            // $('.node-typed-input-property-value').each(function () {
            //     if (!$(this).parent().hasClass(`for-${domain}`)) {
            //         $(this).typedInput('type', 'str');
            //         $(this).typedInput('value', '');
            //     }
            // });
        },
    });
})();
</script>